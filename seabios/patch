diff --git a/src/apm.c b/src/apm.c
index f7c2306c..1778c003 100644
--- a/src/apm.c
+++ b/src/apm.c
@@ -86,12 +86,25 @@ handle_155306(struct bregs *regs)
     set_success(regs);
 }
 
+#define PORT_BIOS_APM 0x8900
+static void
+out_str(const char *str_cs)
+{
+    u8 *s = (u8*)str_cs;
+    for (;;) {
+        u8 c = GET_GLOBAL(*s);
+        if (!c)
+            break;
+        outb(c, PORT_BIOS_APM);
+        s++;
+    }
+}
+
 void
 apm_shutdown(void)
 {
-    u16 pm1a_cnt = GET_GLOBAL(acpi_pm1a_cnt);
-    if (pm1a_cnt)
-        outw(0x2000, pm1a_cnt);
+    dprintf(1, "APM shutdown request\n");
+    out_str("Shutdown");
 
     irq_disable();
     for (;;)
@@ -109,9 +122,11 @@ handle_155307(struct bregs *regs)
     switch (regs->cx) {
     case 1:
         dprintf(1, "APM standby request\n");
+        out_str("Standby");
         break;
     case 2:
         dprintf(1, "APM suspend request\n");
+        out_str("Suspend");
         break;
     case 3:
         apm_shutdown();
diff --git a/src/block.h b/src/block.h
index 3af2d716..46cb96ae 100644
--- a/src/block.h
+++ b/src/block.h
@@ -22,6 +22,7 @@ struct disk_op_s {
             void *cdbcmd;
         };
     };
+    u32 chs; // used by floppy driver
 };
 
 #define CMD_RESET   0x00
diff --git a/src/disk.c b/src/disk.c
index 0328fbd1..f2773bd0 100644
--- a/src/disk.c
+++ b/src/disk.c
@@ -139,15 +139,18 @@ basic_access(struct bregs *regs, struct drive_s *drive_fl, u16 command)
     u16 nlc=chs.cylinder, nlh=chs.head, nls=chs.sector;
 
     // sanity check on cyl heads, sec
+    if (GET_FLATPTR(drive_fl->type) != DTYPE_FLOPPY) {
     if (cylinder >= nlc || head >= nlh || sector > nls) {
         warn_invalid(regs);
         disk_ret(regs, DISK_RET_EPARAM);
         return;
     }
+    }
 
     // translate lchs to lba
     dop.lba = (((((u32)cylinder * (u32)nlh) + (u32)head) * (u32)nls)
                + (u32)sector - 1);
+    dop.chs = (cylinder << 16) | (head << 8) | sector;
 
     dop.buf_fl = MAKE_FLATPTR(regs->es, regs->bx);
 
diff --git a/src/fw/shadow.c b/src/fw/shadow.c
index 8930616e..1ad6c482 100644
--- a/src/fw/shadow.c
+++ b/src/fw/shadow.c
@@ -169,8 +169,7 @@ make_bios_readonly(void)
 void
 qemu_reboot(void)
 {
-    if (!CONFIG_QEMU || runningOnXen())
-        return;
+    return;
     // QEMU doesn't map 0xc0000-0xfffff back to the original rom on a
     // reset, so do that manually before invoking a hard reset.
     void *flash = (void*)BIOS_SRC_OFFSET;
diff --git a/src/hw/floppy.c b/src/hw/floppy.c
index 9e6647d4..1745c3a7 100644
--- a/src/hw/floppy.c
+++ b/src/hw/floppy.c
@@ -143,6 +143,8 @@ addFloppy(int floppyid, int ftype)
     boot_add_floppy(drive, desc, prio);
 }
 
+u8 use_emulink VARLOW;
+
 void
 floppy_setup(void)
 {
@@ -155,6 +157,20 @@ floppy_setup(void)
         return;
     dprintf(3, "init floppy drives\n");
 
+    outl(0, 0xf1f0);
+    u32 magic = inl(0xf1f0);
+    if (magic == 0xaa55ff00) {
+        outl(0x100, 0xf1f0);
+        u8 type = inl(0xf1f0);
+        if (type & 0xf0)
+            addFloppy(0, type >> 4);
+        if (type & 0x0f)
+            addFloppy(1, type & 0x0f);
+        SET_LOW(use_emulink, 1);
+        return;
+    }
+    SET_LOW(use_emulink, 0);
+
     if (CONFIG_QEMU) {
         u8 type = rtc_read(CMOS_FLOPPY_DRIVE_TYPE);
         if (type & 0xf0)
@@ -572,7 +588,11 @@ static struct chs_s
 lba2chs(struct disk_op_s *op)
 {
     struct chs_s res = { };
-
+    u32 tmp = op->chs;
+    res.cylinder = tmp >> 16;
+    res.head = (tmp >> 8) & 0xff;
+    res.sector = tmp & 0xff;
+#if 0
     u32 tmp = op->lba;
     u16 nls = GET_GLOBALFLAT(op->drive_fl->lchs.sector);
     res.sector = (tmp % nls) + 1;
@@ -583,7 +603,7 @@ lba2chs(struct disk_op_s *op)
 
     tmp /= nlh;
     res.cylinder = tmp;
-
+#endif
     return res;
 }
 
@@ -686,6 +706,45 @@ floppy_process_op(struct disk_op_s *op)
     if (!CONFIG_FLOPPY)
         return 0;
 
+    if (GET_LOW(use_emulink)) {
+        switch (op->command) {
+        case CMD_RESET:
+            return 0;
+        case CMD_READ: {
+            u8 floppyid = GET_GLOBALFLAT(op->drive_fl->cntl_id);
+            outl(0x101, 0xf1f0);
+            outl(floppyid, 0xf1f4);
+            outl(op->chs, 0xf1f4);
+            outl(op->count, 0xf1f4);
+            if (inl(0xf1f0) != 0)
+                return DISK_RET_EMEDIA;
+            insb_fl(0xf1f4, op->buf_fl, op->count * 512);
+            if (inl(0xf1f0) != 0)
+                return DISK_RET_EMEDIA;
+            return 0;
+        }
+        case CMD_WRITE: {
+            u8 floppyid = GET_GLOBALFLAT(op->drive_fl->cntl_id);
+            outl(0x102, 0xf1f0);
+            outl(floppyid, 0xf1f4);
+            outl(op->chs, 0xf1f4);
+            outl(op->count, 0xf1f4);
+            if (inl(0xf1f0) != 0)
+                return DISK_RET_EMEDIA;
+            outsb_fl(0xf1f4, op->buf_fl, op->count * 512);
+            if (inl(0xf1f0) != 0)
+                return DISK_RET_EMEDIA;
+            return 0;
+        }
+        case CMD_VERIFY:
+            return 0;
+        case CMD_FORMAT:
+            return 0;
+        default:
+            return DISK_RET_EPARAM;
+        }
+    }
+
     switch (op->command) {
     case CMD_RESET:
         return floppy_reset(op);
diff --git a/src/hw/serialio.c b/src/hw/serialio.c
index fa663b99..48efda12 100644
--- a/src/hw/serialio.c
+++ b/src/hw/serialio.c
@@ -112,8 +112,9 @@ qemu_debug_preinit(void)
 
     /* Check if the QEMU debug output port is active */
     if (CONFIG_DEBUG_IO &&
-        inb(GET_GLOBAL(DebugOutputPort)) != QEMU_DEBUGCON_READBACK)
-        DebugOutputPort = 0;
+        inb(GET_GLOBAL(DebugOutputPort)) != QEMU_DEBUGCON_READBACK) {
+//        DebugOutputPort = 0;
+    }
 }
 
 // Write a character to the special debugging port.
diff --git a/src/misc.c b/src/misc.c
index b5117304..9cdc6d08 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -63,7 +63,7 @@ mathcp_setup(void)
 {
     dprintf(3, "math cp init\n");
     // 80x87 coprocessor installed
-    set_equipment_flags(0x02, 0x02);
+//    set_equipment_flags(0x02, 0x02);
     enable_hwirq(13, FUNC16(entry_75));
 }
 
diff --git a/src/optionroms.c b/src/optionroms.c
index e906ab97..1a0dd129 100644
--- a/src/optionroms.c
+++ b/src/optionroms.c
@@ -463,6 +463,12 @@ vgarom_setup(void)
     RunPCIroms = romfile_loadint("etc/pci-optionrom-exec", 2);
     ScreenAndDebug = romfile_loadint("etc/screen-and-debug", 1);
 
+    if (is_valid_rom((void*)BUILD_ROM_START)) {
+        init_optionrom((void*)BUILD_ROM_START, 0, 1);
+        VgaROM = (void*)BUILD_ROM_START;
+        return;
+    }
+
     // Clear option rom memory
     memset((void*)BUILD_ROM_START, 0, rom_get_max() - BUILD_ROM_START);
 
diff --git a/src/post.c b/src/post.c
index f93106a1..8594e502 100644
--- a/src/post.c
+++ b/src/post.c
@@ -68,6 +68,9 @@ ivt_init(void)
     // set vector 0x79 to zero
     // this is used by 'gardian angel' protection system
     SET_IVT(0x79, SEGOFF(0, 0));
+
+    for (i=0x78; i<=0xff; i++)
+        SET_IVT(i, SEGOFF(0, 0));
 }
 
 static void
